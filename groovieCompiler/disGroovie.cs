using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace groovieCompiler
{
    class disGroovie
    {
        System.IO.BinaryReader grvReader;
        System.IO.StreamWriter asmWriter;

        string genASM;

        int lineNum = 1;
        /// <summary>
        /// Maps script locations (long) to the line number for each opcode (int)
        /// </summary>
        System.Collections.Generic.Dictionary<long, int> scriptLocations;
        /// <summary>
        /// Maps script locations (long) to where they jump to (long)
        /// </summary>
        System.Collections.Generic.List<long> scriptJumps;

        bool t7g;

        int[] opCount = new int[0x60];

        string x16(int i)
        {  return "0x" + Convert.ToString(i, 16); }

        private UInt32 ReadFileRef()
        {
            if (!t7g)
                return grvReader.ReadUInt32();
            else
                return grvReader.ReadUInt16();

        }

        public disGroovie(string input, bool t7g)
        {
            Array.Clear(opCount, 0, 0x60);
            this.t7g = t7g;
            try
            {
                grvReader = new System.IO.BinaryReader(new System.IO.FileStream(input, System.IO.FileMode.Open, System.IO.FileAccess.Read));
            }
            catch (Exception e)
            {
                System.Console.WriteLine("Unable to open file '" + input + "': ");
                System.Console.WriteLine(e.Message);
                return;
            }

            try
            {
                if (input.Contains("."))
                {
                    input = input.Substring(0, input.LastIndexOf("."));
                }
                input += ".gasm";
                asmWriter  = new System.IO.StreamWriter(new System.IO.FileStream(input, System.IO.FileMode.Create, System.IO.FileAccess.Write));
            }
            catch (Exception e)
            {
                System.Console.WriteLine("Unable to create output '" + input + "':");
                System.Console.WriteLine(e.Message);
                grvReader.Close();
                return;
            }

            scriptLocations  = new Dictionary<long,int>();
            scriptJumps = new List<long>();

            System.Windows.Forms.TextBox asmTxt = new System.Windows.Forms.TextBox();
            genASM = ";Groovie script file generated by groovieCompiler\n";

            int ctr = 0;
            lineNum = 1;
            while (grvReader.BaseStream.Position < grvReader.BaseStream.Length)
            {
                //yay
                scriptLocations.Add(grvReader.BaseStream.Position, lineNum);
                lineNum++;
                if (!parseOpcode())
                {

                    grvReader.Close();
                    asmWriter.Write(genASM);
                    asmWriter.Close();
                    Console.WriteLine("Aborted due to error reading opcodes");
                    Console.WriteLine("Debug information dumped to " + input);
                    return;
                }
                ctr++;
                if (ctr > 100)
                {
                    ctr = 0;
                    Console.WriteLine("\r{0}", grvReader.BaseStream.Position / (float)grvReader.BaseStream.Length);
                }
            }

            asmTxt.Text = genASM;
            string[] lines = new string[asmTxt.Lines.Length];
            asmTxt.Lines.CopyTo(lines, 0);

            scriptJumps.Sort();
            long prev = -1;
            foreach (long called in scriptJumps)
            {
                if (called == prev)
                    continue;

                prev = called;
                try
                {
                    lineNum = scriptLocations[called];
                }
                catch
                {
                    System.Console.WriteLine("Jumped out of script?!?  0x" + Convert.ToString(called, 16));
                    lineNum = lines.Length - 1;
                }
                lines[lineNum] = "\nloc_" + called + "\t\t; 0x" + Convert.ToString(called,16) + "\n" + lines[lineNum];
            }

            genASM = "";
            foreach (string line in lines)
            {
                genASM += (line + "\n");
            }

            System.Console.WriteLine("Opcodes used:");
            for (int i = 0; i < 0x60; i++)
            {
                //if (opCount[i] > 0)
                    System.Console.WriteLine(/*"  {0:X}: {1}"*/ "{1}", i, opCount[i]);
            }

            asmWriter.Write(genASM);
            asmWriter.Close();
        }

        public bool parseOpcode()
        {
            bool firstBit;
            byte op;

            // Get opcode
            op = grvReader.ReadByte();
            // Check if first bit set
            if ((op & 128) == 128)
            {
                op &= 127;
                firstBit = true;
            }
            else
            {
                firstBit = false;
            }
            try
            {
                opCount[op]++;
            }
            catch (Exception e)
            {
                Console.WriteLine("Bad opcode: " + op);
            }

            /*
             * if (something)
             *   vars[0x103]++;
             * 
             */

            //if (VDXFlags.op400D == 2)
            //{
            //    // Play midi
            //    music.playLoop(1);
            //    VDXFlags.op400D = 0;

            //}

            /* if (.op1c05 > 0) ?
             *   do things
             */

            /* if (.op2042 & 0x80)
             *   do stuff/jump
             *   .op2402 = 0
             */


            //Console.WriteLine("Opcode 0x{0:X}", op);
            //if (scriptJumps
            switch (op)
            {
                #region NOP's
                case 0x28:
                case 0x4A:
                case 0x4F:
                case 0x50:
                    // 2 byte NOP
                    {
                        ushort arg = grvReader.ReadUInt16();
                        genASM += ("\tNOP");
                    }
                    break;

                case 0x1E:
                case 0x48:
                case 0x4B:
                    // 1 Byte NOP
                    {
                        byte arg = grvReader.ReadByte();
                        genASM += ("\tNOP");
                    }
                    break;

                case 0x01:
                case 0x46:
                case 0x49:
                case 0x47:
                    // NOP
                    genASM += ("\tNOP");
                    break;

                case 0x59:
                    // Variable size NOP
                    {
                        ushort arg1, arg2;
                        if (firstBit)
                            arg1 = grvReader.ReadByte();
                        else
                            arg1 = grvReader.ReadUInt16();
                        arg2 = grvReader.ReadByte();
                        //Console.WriteLine("NOP variable: 0x{0:X} with args 0x{1:X}, 0x{2:X}", op, arg1, arg2);
                        genASM += ("\tOp59\t0x" + Convert.ToString(arg1, 16) + ", 0x" + Convert.ToString(arg2, 16));
                    }
                    break;

                #endregion

                #region Bitflags (3, 5, 6, 7, A, 35, 57)

                case 0x03:
                    // Enable bit 9
                    genASM += ("\tFADIN");
                    break;

                case 0x05:
                    // Bit 8 (just still ?)
                    genASM += ("\tBF8ON");
                    break;

                case 0x06:
                    // Bit 6
                    genASM += ("\tBF6ON");
                    break;

                case 0x07:
                    // Bit 7 - Just audio?
                    genASM += ("\tBF7ON");
                    break;

                case 0x0A:
                    // Bit 5 - skip stills?
                    genASM += ("\tBF5ON");
                    break;

                case 0x35: // just audio
                    genASM += ("\tBF7OFF");
                    break;

                case 0x57:
                    // unimplemented
                    Console.WriteLine("op57");
                    return false;

                case 0x58:
                    // unimplemented
                    genASM += "\tOp58\t" + readAwk2() + "; unknown pvdx style";
                    Console.WriteLine("op58");
                    //return false;
                    break;

                #endregion

                #region Mouse clicks - D, E, F, 10, 11, 12, 2C, 2D, 30, 44, 45, 53)

                case 0x0D:
                    // Mark a rectangle clickable.  On hover, show cursor arg6.  Jump to arg5 on click
                    {
                        ushort left = grvReader.ReadUInt16();
                        ushort top = grvReader.ReadUInt16();
                        ushort right = grvReader.ReadUInt16();
                        ushort bottom = grvReader.ReadUInt16();
                        ushort jump = grvReader.ReadUInt16();
                        scriptJumps.Add(jump);
                        byte cursor = grvReader.ReadByte();
                        genASM += ("\tHOTREC\tloc_" + jump + ", " + left + ", " + top + ", " + right + ", " + bottom + ", " + cursor);
                    }
                    break;
                case 0x0E:
                    // Left 100px clickable 
                    {
                        ushort offset = grvReader.ReadUInt16();
                        scriptJumps.Add(offset);
                        genASM += ("\tHOTL\tloc_" + offset);
                    }
                    break;

                case 0x0F:
                    // Right 100px clickable 
                    {
                        ushort offset = grvReader.ReadUInt16();
                        scriptJumps.Add(offset);
                        genASM += ("\tHOTR\tloc_" + offset);
                    }
                    break;

                case 0x10:
                case 0x11:
                    // Middle 240px clickable
                    {
                        ushort offset = grvReader.ReadUInt16();
                        scriptJumps.Add(offset);
                        genASM += ("\tHOTC\tloc_" + offset);
                    }
                    break;

                case 0x12:
                    // Current pos clickable
                    {
                        ushort offset = grvReader.ReadUInt16();
                        scriptJumps.Add(offset);
                        genASM += ("\tHOTFULL\tloc_" + offset);
                    }
                    break;

                case 0x30:
                    // Bottom 80px clickable
                    {
                        ushort offset = grvReader.ReadUInt16();
                        scriptJumps.Add(offset);
                        genASM += ("\tHOTB\tloc_" + offset);
                    }
                    break;


                case 0x2C:
                    {
                        // Destination and cursor for top hotspot
                        ushort offset = grvReader.ReadUInt16();
                        scriptJumps.Add(offset);
                        genASM += ("\tHOTTC\tloc_" + offset + ", " + grvReader.ReadByte());
                    }
                    break;

                case 0x2D:
                    {
                        // Destination and cursor for bottom hotspot
                        ushort offset = grvReader.ReadUInt16();
                        scriptJumps.Add(offset);
                        genASM += ("\tHOTBC\tloc_" + offset + ", " + grvReader.ReadByte());
                    }
                    break;

                case 0x44:
                    {
                        // Destination for right hotspot

                        //standardHotspot[1].jumpAddress = stream.ReadUInt16();
                        ushort offset = grvReader.ReadUInt16();
                        scriptJumps.Add(offset);
                        genASM += ("\tHOTRD\tloc_" + offset);
                    }
                    break;

                case 0x45:
                    {
                        // Destination for left hotspot

                        //standardHotspot[3].jumpAddress = stream.ReadUInt16();
                        ushort offset = grvReader.ReadUInt16();
                        scriptJumps.Add(offset);
                        genASM += ("\tHOTLD\tloc_" + offset);
                        //throw new Exception("Action for left hotspot");
                    }
                    break;

                case 0x3B:
                    // Savegame stuff, inc rendering sphinx.fnt
                    {
                        byte slot = grvReader.ReadByte();
                        ushort left = grvReader.ReadUInt16(), top = grvReader.ReadUInt16(), right = grvReader.ReadUInt16(), bottom = grvReader.ReadUInt16(); 
                        ushort offset = grvReader.ReadUInt16();
                        byte cursor = grvReader.ReadByte();
                        genASM += "\tHOTSAV\t" + slot + ", loc_" + offset + ", " + left + ", " + top + ", " + right + ", " + bottom + ", " + cursor;
                        scriptJumps.Add(offset);
                    }
                    break;

                case 0x0B:
                    // Start input loop
                    //if (inputLoopPos == 0)
                    //    inputLoopPos = stream.BaseStream.Position - 1;

                    //game.removeHotspot();

                    // Something midi related here

                    // Play loop midi perhaps - if not midi playing already?

                    //Console.WriteLine("Start input loop");
                    genASM += ("\tGOIN\t\t;Start input");
                    break;

                case 0x0C:
                    // Keyboard related
                    //game.addHotspot(stream.ReadByte(), stream.ReadUInt16());
                    {
                        byte val = grvReader.ReadByte();
                        ushort offset = grvReader.ReadUInt16();
                        scriptJumps.Add(offset);
                        genASM += ("\tHOTKEY\tloc_" + offset + ", " + val + "  ; " + ((char)val).ToString());
                    }
                    break;

                case 0x13:
                    // End input loop
                    // Checks if mouse inputs have passed
                    // Jump to input loop start

                    //stream.BaseStream.Seek(inputLoopPos, SeekOrigin.Begin);
                    genASM += ("\tSTIN\t\t;Stop input");
                    break;

                #endregion

                case 0x02:
                    // Play "XMI".  Unfortunately that's a little hard at the moment so play MIDI conversion
                    {
                        genASM += ("\tPMID\t" + ReadFileRef());
                    }
                    break;

                case 0x04:
                    // Fade out                        
                    //game.removeVDX();
                    genASM += ("\tFADOUT");
                    break;

                case 0x08:
                    // Loop XMI file?
                    {
                        genASM += ("\tMIDLOOP\t" + ReadFileRef());
                    }
                    break;

                case 0x4E:
                    {
                        genASM += ("\tMIDDELAY\t" + grvReader.ReadUInt16());
                    }
                    break;

                #region Display related

                case 0x22:
                    // Copy bg to fg
                    genASM += ("\tBG2FG\t");
                    //game.copyBuffer();
                    break;

                case 0x37:
                    // Copy screen to game buffer
                    {
                        ushort left = grvReader.ReadUInt16(), top = grvReader.ReadUInt16(), right = grvReader.ReadUInt16(), bottom = grvReader.ReadUInt16();
                        genASM += ("\tREC2BG\t" + left + ", " + top + ", " + right + ", " + bottom);
                    }
                    break;

                case 0x09:
                    // Play VDX
                    {
                        genASM += ("\tPVDX\t" + ReadFileRef());
                    }
                    break;

                case 0x1C:
                    {
                        // Play VDX - 2nd type (simple)
                        genASM += ("\tPVDX2\t" + ReadFileRef());

                    }
                    break;


                case 0x26:
                    //throw new Exception("Other awkward - library book tripped?");

                    //Console.WriteLine("Op26");
                    //return false;
                    {
                        genASM += "\tPVDXSTR\t" + readAwk2();
                        break;
                    }
                    //// Load a GJD here somewhere as well


                case 0x27:
                    // Turns on bit 2 of bitflags (and bit 3 if firstbit is set). VDX file name (in a .gjd) follows: find it, then play it
                    {
                        //Console.WriteLine("Op27");
                        //return false;
                        genASM += "\tPVDXSTR2\t" + readAwk2() + "\t;Same as PVDXSTR but set BF1 and optionally BF2";
                    }
                    break;

                #endregion

                case 0x14:
                    // Random number generation
                    {
                        ushort offset;
                        if (firstBit)
                            offset = grvReader.ReadByte();
                        else
                            offset = grvReader.ReadUInt16();
                        genASM += ("\tRAND\t0x" + Convert.ToString(offset,16) + ", " + grvReader.ReadByte());
                    }
                    break;

                case 0x15:
                    // Jump
                    {
                        ushort jump = grvReader.ReadUInt16();
                        scriptJumps.Add(jump);
                        genASM += ("\tJMP\tloc_" + jump);
                    }
                    break;

                case 0x16:
                    // Reads a string into the script variable specified in the first 2 (or 1) bytes
                    {
                        ushort offset;
                        if (firstBit)
                            offset = grvReader.ReadByte();
                        else
                            offset = grvReader.ReadUInt16();

                        genASM += ("\tMOVS\tvar[0x" + Convert.ToString(offset, 16)) + "...] = ";

                        string tmp = "";
                        do
                        {
                            tmp += readScriptChar(true, true, true) + ", ";
                            grvReader.BaseStream.Seek(-1, System.IO.SeekOrigin.Current);
                        } while ((grvReader.ReadByte() & 0x80) == 0);
                        genASM += tmp.Substring(0, tmp.Length - 2);
                    }
                    break;

                case 0x17:
                    // Return from CALL
                    //vars[0x102] = stream.ReadByte();
                    genASM += ("\tRET\t" + grvReader.ReadByte());
                    //stream.BaseStream.Seek(callStack.Pop(), SeekOrigin.Begin);
                    break;

                case 0x18:
                    // CALL
                    {
                        //callStack.Push(stream.BaseStream.Position + 2);
                        ushort offset = grvReader.ReadUInt16();
                        //stream.BaseStream.Seek(offset, SeekOrigin.Begin);

                        scriptJumps.Add(offset);
                        genASM += ("\tCALL\tloc_" + offset);
                    }
                    break;

                case 0x19:
                    // Sleep
                    //System.Console.WriteLine("Slept for a little bit");
                    //System.Threading.Thread.Sleep(stream.ReadUInt16() * 3);
                    genASM += ("\tSLEEP\t" + grvReader.ReadUInt16());
                    break;

                #region String compare + jump (op 1A and 23)
                case 0x1A:
                case 0x23:
                    {
                        // Get var location
                        ushort offset;
                        if (firstBit)
                            offset = grvReader.ReadByte();
                        else
                            offset = grvReader.ReadUInt16();

                        string l = ", 0x" + System.Convert.ToString(offset, 16);

                        // JE or JNE?
                        if (op == 0x1A)
                        {
                            genASM += ("\tJNE\tloc_");
                        }
                        else
                        {
                            genASM += ("\tJE\tloc_");
                        }


                        byte t;

                        do
                        {
                            // Read byte
                            l += ", " + readAwk1();

                            // Break when needed
                            //offset++;

                            grvReader.BaseStream.Seek(-1, System.IO.SeekOrigin.Current);
                            t = grvReader.ReadByte();
                            //l += ", " + (t & 0x7f);
                        } while ((t & 0x80) != 0x80);

                        offset = grvReader.ReadUInt16();
                        scriptJumps.Add(offset);
                        genASM += (offset + l);
                        
                    }
                    break;
                #endregion

                case 0x1B:
                    // XOR
                    {
                        ushort offset;
                        if (firstBit)
                            offset = grvReader.ReadByte();
                        else
                            offset = grvReader.ReadUInt16();
                        genASM += ("\tXOR\t0x"+Convert.ToString(offset, 16));
                        byte t;
                        do
                        {
                            t = grvReader.ReadByte();
                            t &= 0x4F;
                            genASM += (", " + t);
                            grvReader.BaseStream.Seek(-1, System.IO.SeekOrigin.Current);
                            t = grvReader.ReadByte();
                        } while ((t & 0x80) == 0);
                        genASM += ("\t;XOR variables starting at offset, with each extra parameter");
                    }
                    break;

                case 0x1D:
                    // Swap to variables
                    {
                        ushort offa, offb;
                        if (firstBit)
                            offa = grvReader.ReadByte();
                        else
                            offa = grvReader.ReadUInt16();

                        offb = grvReader.ReadUInt16();
                        genASM += ("\tSWAP\t0x" + Convert.ToString(offa, 16) + ", 0x" + Convert.ToString(offb, 16));
                    }
                    break;

                case 0x1F:
                    // INC
                    if (firstBit)
                        genASM += ("\tINC\t0x" + Convert.ToString(grvReader.ReadByte(), 16));
                    else
                        genASM += ("\tINC\t0x" + Convert.ToString(grvReader.ReadUInt16(), 16));

                    break;

                case 0x20:
                    // DEC
                    if (firstBit)
                        genASM += ("\tDEC\t0x" + Convert.ToString(grvReader.ReadByte(), 16));
                    else
                        genASM += ("\tDEC\t0x" + Convert.ToString(grvReader.ReadUInt16(), 16));

                    break;

                case 0x21:
                    {
                        // call something
                        if (firstBit)
                            genASM += "\tSTRCMPJNE\t" + grvReader.ReadByte();
                        else
                            genASM += "\tSTRCMPJNE\t" + grvReader.ReadUInt16();

                        genASM += ", " + readAwk2();
                        uint jmp = grvReader.ReadUInt16();
                        genASM += " loc_" + jmp;
                        scriptJumps.Add(jmp);

                        //    ushort offset = 0; /* = (ushort)functionCall();*/
                        //    if (offset > 0x09)
                        //    {
                        //        offset -= 7;
                        //    }
                        //    // loc_4031CF
                        //    offset = vars[offset + 0x19];
                        //    byte match = 1, x, y, z;

                        //    // loc_4031F6
                        //    do
                        //    {
                        //        x = vars[offset];
                        //        y = awkward1();
                        //        offset++;
                        //        if (x != y)
                        //            match = 0;

                        //        // loc_403237
                        //        stream.BaseStream.Seek(-1, SeekOrigin.Current);
                        //        z = stream.ReadByte();
                        //    } while ((z & 0x80) == 0);

                        //    offset = stream.ReadUInt16();
                        //    if (match == 0)
                        //        stream.BaseStream.Seek(offset, SeekOrigin.Begin);
                        //}
                        //throw new Exception("Unknown param awk call");
                    }
                    break;

                case 0x33:
                    // Copy string into arg1
                    {
                        ushort offset;
                        if (firstBit)
                            offset = grvReader.ReadByte();
                        else
                            offset = grvReader.ReadUInt16();

                        genASM += "\tLOADSTR\t0x" + Convert.ToString(offset, 16);

                        do{
                            genASM += ", " + readAwk1();
                            grvReader.BaseStream.Seek(-1, System.IO.SeekOrigin.Current);
                        } while ((grvReader.ReadByte() & 0x80) == 0);

                        genASM += "\t\t;Load string into variable located by [\'var[param1]-0x31\'] ";
                        break;
                        
                        //ushort offset;
                        //if (firstBit)
                        //    offset = stream.ReadByte();
                        //else
                        //    offset = stream.ReadUInt16();
                        //offset = vars[offset];
                        //offset -= 0x31;

                        //// loc_403678
                        //byte b;
                        //do
                        //{
                        //    b = awkward1();
                        //    vars[offset] = b;//???
                        //    offset++;

                        //    vars[vars[offset++]] = (byte)(b & 0x7f);
                        //    stream.BaseStream.Seek(-1, SeekOrigin.Current);
                        //    b = stream.ReadByte();
                        //} while ((b & 0x80) == 0);
                    }
          

                case 0x3A:
                    // "Print" string?
                    {
                        genASM += "\tPRINT\t";
                        if (!t7g)
                        {
                            genASM += grvReader.ReadUInt16() + ", " + grvReader.ReadUInt16() + ", ";
                            genASM += grvReader.ReadByte() + ", " + grvReader.ReadByte() + ", " + grvReader.ReadByte() + ", ";
                        }
                        string l = "";
                        bool done = false;
                        do
                        {
                            l += readAwk1() + ", ";

                            if (t7g && (grvReader.BaseStream.Seek(-1, System.IO.SeekOrigin.Current) > 0 && (grvReader.ReadByte() & 0x80) != 0))
                                done = true;
                            else if (!t7g && (grvReader.PeekChar() == 0))
                            {
                                grvReader.ReadByte();
                                done = true;
                            }
                        } while (!done);
                        genASM += l.Substring(0, l.Length - 2);
                        break;
                    }
                 

                case 0x36:
                case 0x34:
                    // Check stream of characters - var[off] < b or var[offset] > b
                    {
                        ushort offset;
                        if (op == 0x34)
                            genASM += ("\tJG\tloc_");
                        else
                            genASM += ("\tJL\tloc_");

                        if (firstBit)
                            offset = grvReader.ReadByte();
                        else
                            offset = grvReader.ReadUInt16();

                        string l = ", 0x" + Convert.ToString(offset, 16);
                        do
                        {
                            l += ", " + readAwk1();
                            grvReader.BaseStream.Seek(-1, System.IO.SeekOrigin.Current);
                        } while ((grvReader.ReadByte() & 0x80) == 0);

                        offset = grvReader.ReadUInt16();
                        scriptJumps.Add(offset);
                        genASM += (offset + l);
                        
                        //Console.WriteLine("Unimplemented 36/34");
                        //return false;
                        //ushort offset;
                        //if (firstBit)
                        //    offset = stream.ReadByte();
                        //else
                        //    offset = stream.ReadUInt16();

                        //// Check stream to see if equal var[offset]
                        //byte b;
                        //byte match = 0;
                        //if (op == 0x34)
                        //{
                        //    do
                        //    {
                        //        b = awkward1();
                        //        if (vars[offset] > b)
                        //            match = 1;

                        //        //offset++;

                        //        stream.BaseStream.Seek(-1, SeekOrigin.Current);
                        //        b = stream.ReadByte();
                        //        // Keep looping till end of string
                        //    } while ((b & 0x80) == 0);
                        //}
                        //else
                        //{
                        //    do
                        //    {
                        //        b = awkward1();
                        //        if (vars[offset] < (b & 0x7F))
                        //            match = 1;
                        //        offset++;

                        //        stream.BaseStream.Seek(-1, SeekOrigin.Current);
                        //        b = stream.ReadByte();
                        //        // Keep looping till end of string
                        //    } while ((b & 0x80) == 0);
                        //}

                        //offset = stream.ReadUInt16();
                        //if (match == 1)
                        //{
                        //    stream.BaseStream.Seek(offset, SeekOrigin.Begin);
                        //}
                    }
                    break;

                case 0x24:
                    // MOV
                    {
                        ushort offset;
                        if (firstBit)
                            offset = grvReader.ReadByte();
                        else
                            offset = grvReader.ReadUInt16();

                        genASM += ("\tMOV\t0x" + Convert.ToString(offset, 16) + ", " + grvReader.ReadUInt16());
                    }
                    break;

                case 0x25:
                    // ADD
                    {
                        ushort offset;
                        if (firstBit)
                            offset = grvReader.ReadByte();
                        else
                            offset = grvReader.ReadUInt16();

                        genASM += ("\tADD\t0x" + Convert.ToString(offset, 16) + ", " + grvReader.ReadUInt16());
                    }
                    break;

                case 0x29:
                    // Stop MIDI
                    genASM += ("\tSMID\t\t;Stop midi");
                    break;

                case 0x2A:
                    // Close things
                    // Close current GJD
                    // Stop midi
                    // Clear hotspots

                    genASM += ("\tEXIT");
                    break;

                case 0x2E:
                    {
                        ushort offset;
                        if (firstBit)
                            offset = grvReader.ReadByte();
                        else
                            offset = grvReader.ReadUInt16();

                        genASM += ("\tLOAD\t0x" + Convert.ToString(offset, 16));
                        //BinaryReader save = new BinaryReader(new FileStream(path + "t7g4win.00" + ((vars[offset]).ToString()), FileMode.Open, FileAccess.Read));
                        //vars = save.ReadBytes(vars.Length);
                        //save.Close();
                        //Console.WriteLine("Loading game from slot " + (vars[offset].ToString()) + "?");
                    }
                    break;

                case 0x2F:
                    {
                        ushort offset;
                        if (firstBit)
                            offset = grvReader.ReadByte();
                        else
                            offset = grvReader.ReadUInt16();

                        genASM += ("\tSAVE\t0x" + Convert.ToString(offset, 16));
                        //BinaryWriter save = new BinaryWriter(new FileStream(path + "t7g4win.00" + (vars[offset].ToString()), FileMode.Create, FileAccess.Write));
                        //save.Write(vars, 0, vars.Length);
                        //save.Close();
                        //Console.WriteLine("Save game to slot" + (vars[offset].ToString()) + "?");
                    }
                    break;

                case 0x31:
                    // Set MIDI volume.
                    {
                        ushort arg1 = grvReader.ReadUInt16(), arg2 = grvReader.ReadUInt16();
                        genASM += ("\tMIDVOL\t" + arg1 + ", " + arg2);

                    }
                    break;

                case 0x32:
                    // JNE
                    {
                        ushort arg1;
                        if (firstBit)
                            arg1 = grvReader.ReadByte();
                        else
                            arg1 = grvReader.ReadUInt16();

                        ushort arg2 = grvReader.ReadUInt16();
                        ushort offset = grvReader.ReadUInt16();

                        genASM += "\tJNE\tloc_" + offset + ", " + arg1 + ", " + arg2 + "; var[var[arg1] - 0x31] != var[arg2]";
                        scriptJumps.Add(offset);
                    }
                    break;

                case 0x38:
                    // Reload stored stack pointer
                    //Console.WriteLine("Reload stored stack pointer - TODO");
                    genASM += ("\tRLD");
                    break;

                case 0x39:
                    // "Obscure" swap
                    {

                        //Console.WriteLine("Unimplemented 39");
                        //return false;

                        genASM += "\tSWAP\t vars[10*" + readScriptChar(false, true, true) + " + " + readScriptChar(false, true, true) + " + 25]";
                        genASM += " <=> vars[10*" + readScriptChar(false, true, true) + " + " + readScriptChar(false, true, true) + " + 25] ";

                        /*

                        // .text:0040389B
                        ushort arg1, arg2, arg3;

                        arg1 = grvReader.ReadByte();
                        genASM += ", " + arg1;
                        arg1 &= 0x7F;

                        if (arg1 == 0x23)
                        {
                            arg1 = grvReader.ReadByte();
                            genASM += ", " + arg1;
                        }
                        //    arg1 &= 0x7F;
                        //    arg1 = vars[arg1 - 0x61];
                        //    arg1 *= 10;
                        //}
                        //else
                        //{
                        //    arg1 -= 0x30;
                        //    arg1 *= 10;
                        //}

                        arg2 = grvReader.ReadByte();
                        arg2 &= 0x7F;
                        genASM += ", " + arg2;

                        if (arg2 == 0x23)
                        {
                            arg2 = grvReader.ReadByte();
                            genASM += ", " + arg2;
                        }
                        //    arg2 &= 0x7F;
                        //    arg1 += vars[arg2 - 0x61];
                        //}
                        //else
                        //{
                        //    arg1 = vars[arg1 + arg2];
                        //}

                        //arg1 += 0x19;

                        //// .text:0040394D (loc_40393E + 4lines)

                        arg3 = grvReader.ReadByte();
                        arg3 &= 0x7F;
                        genASM += ", " + arg3;

                        if (arg3 == 0x23)
                        {
                            arg3 = grvReader.ReadByte();
                            genASM += ", " + arg3;
                        }
                        //    arg3 &= 0x7F;
                        //    arg3 = vars[arg3 - 0x61];
                        //    arg3 *= 10;
                        //}
                        //else
                        //{
                        //    arg3 -= 0x30;
                        //    arg3 *= 10;
                        //}

                        arg2 = grvReader.ReadByte();
                        arg2 &= 0x7F;
                        genASM += ", " + arg2;

                        if (arg2 == 0x23)
                        {
                            arg2 = grvReader.ReadByte();
                            genASM += ", " + arg2;
                        }
                        //    arg2 &= 0x7F;
                        //    arg3 += vars[arg2 - 0x61];
                        //}
                        //else
                        //{
                        //    arg3 = vars[arg3 + arg2];
                        //}

                        //arg3 += 0x19;

                        //// now got an arg1 (varOffset2) and arg3 (var13C)
*/
                        //byte tmp;
                        //tmp = vars[arg1];
                        //vars[arg1] = vars[arg2];
                        //vars[arg2] = tmp;
                    }
                    break;

                case 0x3C:
                    // Check valid savegames
                    {
                        genASM += ("\tCSAVE\t\t;Check saves");
                    }
                    break;

                case 0x3D:
                    // Reset 0x00 to 0xFF to zero
                    genASM += ("\tCLRVARS");
                    break;

                case 0x3E:
                    // MOD
                    {
                        Console.WriteLine("Needs work? to trace?");
                        ushort offset;
                        if (firstBit)
                            offset = grvReader.ReadByte();
                        else
                            offset = grvReader.ReadUInt16();

                        genASM += ("\tMOD\t0x" + Convert.ToString(offset, 16) + ", " + grvReader.ReadByte());

                    }
                    break;

                case 0x3F:
                    // Load subscript
                    {
                        genASM += "\tLOADSUB\t";
                        char t;
                        string ret = "";
                        while ((t = grvReader.ReadChar()) != 0)
                            ret += t + ", ";

                        genASM += ret.Substring(0, ret.Length - 2);
                        break;
                        //Console.WriteLine("Unimplemented 3F");
                        //return false;
                        //Console.WriteLine("Run a subscript");
                        //char c;
                        //string f = "";
                        //do
                        //{
                        //    //t = stream.ReadByte();
                        //    c = (char)stream.ReadByte();
                        //    if (c != 0)
                        //        f += c;// t.ToString();
                        //} while (c != 0);

                        //sub = new Groovie(f, game);
                        //sub.passParams(ref vars, music, ref flags, vdx);
                    }
            

                case 0x40:
                    // Two params for VDX player
                    {
                        genASM += "\tSETCOORD\t" + grvReader.ReadUInt16() + ", " + grvReader.ReadUInt16() + "\t;Set video start @ arg1,arg2";
                        //flags |= bitFlags.Bit7;
                        //ushort arg1 = stream.ReadUInt16();
                        //if (arg1 > 0x7FFF)
                        //{
                        //    /*
                        //     *  .text:00403E62 154         mov     ecx, arg1
                        //        .text:00403E68 154         sub     ecx, 10000h     ; Integer Subtraction
                        //        .text:00403E6E 154         mov     arg1, ecx

                        //     */
                        //}
                        //stream.ReadUInt16();
                        //// Same for arg2
                        //throw new Exception("Two VDX player params");
                    }
                    break;

                case 0x41:
                    // SUB
                    {
                        ushort offset;
                        if (firstBit)
                            offset = grvReader.ReadByte();
                        else
                            offset = grvReader.ReadUInt16();

                        genASM += ("\tSUB\t0x" + Convert.ToString(offset, 16) + ", " + grvReader.ReadUInt16());
                    }
                    break;

                case 0x42:
                    //throw new Exception("Complicated");
                    //stream.ReadByte();
                    //Console.WriteLine("Unimplemented - Othello AI");
                    //return false;
                    genASM += "\tOTHELLO\t" + grvReader.ReadByte();
                    break;
                
                case 0x43:
                    // Return from subscript
                    //vars[0x102] = stream.ReadByte();
                    //Console.WriteLine("Unimplemented - ret from script");
                    // Say we're done in this script :)
                    //return false;
                    genASM += ("\tRETFS\t" + grvReader.ReadByte());
                    break;
             

                case 0x4C:
                    // Save current CD number.  1, 2, -1.
                    {
                        genASM += ("\tCCD");
                    }
                    break;

                case 0x4D:
                    // If arg1 == 2, play VIE logo, stop midi, play CD
                    //if (stream.ReadByte() == 2)
                    //{
                    //    // do some other checks on 0x09 flags?

                    //    //VDX vdx = new VDX("vielogo", flags, game.GraphicsDevice);
                    //    //game.addVDX(vdx);
                    //    //vdx.play();
                    //    //while (vdx.playing)
                    //    //    System.Threading.Thread.Sleep(50);
                    //}
                    //if (music == null)
                    //    music = new GrvMusic(game);

                    //music.CD();
                    genASM += ("\tPCD\t" + grvReader.ReadByte());
                    break;

                case 0x51:
                    {
                        UInt16 jmp = grvReader.ReadUInt16();
                        genASM += ("\tOp51\t" + jmp);
                        scriptJumps.Add(jmp);
                    }
                    break;

                case 0x52:
                    // Do heap to game area.  Arg discarded? o2_copyfgtobg
                    // .text:00403B22
                    genASM += ("\tCopyFgToBg\t" + grvReader.ReadByte());
                    break;

                case 0x53:
                    // Load cursor stuff o_hotspot_outrect
                    genASM += ("\toutrect\t" + grvReader.ReadUInt16() + ", " + grvReader.ReadUInt16() + ", " + grvReader.ReadUInt16() + ", " + grvReader.ReadUInt16() + ", " + grvReader.ReadUInt16());
                    break;

                case 0x55:
                    genASM += ("\tSetScriptEnd\t" + grvReader.ReadUInt16());
                    break;

                case 0x56:
                    // o2_playsound
                    genASM += ("\tSound\t" + grvReader.ReadUInt32() + ", " + grvReader.ReadByte() + ", " + grvReader.ReadByte());
                    break;

                case 0x5A:
                    // o2_preview_loadgame
                    genASM += ("\tPreviewLoadGame\t" + grvReader.ReadByte());
                    break;

                default:
                    Console.WriteLine("Invalid opcode at location 0x" + Convert.ToString(grvReader.BaseStream.Position - 1, 16) + ": " + op);
                    return false;

            }
            genASM += ("\n");
            return true;
        }

        /// <summary>
        /// Awkward videoRefFromString
        /// </summary>
        /// <returns></returns>
        private string readAwk2()
        {
            string ret = "";
            byte data;
            while ((data = grvReader.ReadByte()) != 0)
            {
                if (data == 0x23)
                {
                    data = grvReader.ReadByte();
                    ret += "var[" + x16((byte)((data & 0x7f) - 0x61)) + "], ";
                }
                else if (data == 0x7C)
                {
                    /*string val, val2;
                    data = grvReader.ReadByte();
                    if (data == 0x23)
                    {
                        data = grvReader.ReadByte();
                        val = "var[" + (byte)(data - 0x61) + "]";
                    }
                    else
                    {
                        val = "" + (byte)(data - 0x30);
                    }

                    data = grvReader.ReadByte();
                    if (data == 0x23)
                    {
                        data = grvReader.ReadByte();
                        val2 = "var[" + (byte)(data - 0x61) + "]";
                    }
                    else
                    {
                        val2 = "" + (byte)(data - 0x30);
                    }*/

                    ret += "var[10*" + readScriptChar(false, false, false) + " + " + readScriptChar(false, false, false) + " + 25]+0x30, ";
                }
                else
                {
                    // simple read
                    //data -= 0x30;
                    ret += "'" + (char)(data) + "', ";
                }
            }
            return ret;
        }

        /// <summary>
        /// Awkward readScriptCharacter
        /// </summary>
        /// <returns></returns>
        private string readAwk1()
        {
            byte data = (byte)(grvReader.ReadByte() & 0x7f);
            string ret;

            if (data == 0x23)
            {
                ret = "Arr1D";

                grvReader.BaseStream.Seek(-1, System.IO.SeekOrigin.Current);
                while (grvReader.PeekChar() == 0x23)
                {
                    grvReader.ReadByte();
                    data = grvReader.ReadByte();
                    ret += ", " + (byte)((data & 0x7f) - 0x61);
                    if ((data & 0x80) == 0x80)
                        break;
                }

                if ((data & 0x80) == 0)
                {
                    Console.WriteLine("Mass failure on 1D array reading");
                }
                
                //byte data2 = (byte)(grvReader.ReadByte() & 0x7f);

            }
            else if (data == 0x7C)
            {
                // 2D array
                byte data2, data3 = 0;
                data2 = grvReader.ReadByte();
                data3 = data2;
                if (data2 == 0x23)
                {
                    data2 -= 0x61;
                    //data2 = vars[data2]; 
                }
                else
                {
                    //data2 = vars[data2 - 0x30];
                }
                ret = "FAIL";
            }
            else
            {
                // simple read
                data -= 0x30;
                ret = data.ToString();
            }

            return ret;
        }

        private string readScriptChar(bool allow7C, bool limitVal, bool limitVar)
        {
            //byte result;
            byte data = grvReader.ReadByte();

            if (limitVal)
            {
                data &= 0x7F;
            }

            if (allow7C && (data == 0x7C))
            {
                // Index a bidimensional array
                string parta, partb;
                parta = readScriptChar(false, false, false); ;
                partb = readScriptChar(false, true, true);
                return "vars[10*" + parta + " + " + partb + " + 25]";
            }
            else if (data == 0x23)
            {
                // Index an array
                data = grvReader.ReadByte();
                if (limitVar)
                {
                    data &= 0x7F;
                }
                return "vars[" + x16((byte)(data - 0x61)) + "]";
            }
            else
            {
                // Immediate value
                return (data - 0x30).ToString();
            }
            return "WTF";
        }
    }
}
